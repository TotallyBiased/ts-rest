import { InstallTabs } from '@site/src/components/InstallTabs';

# React Query

Fully typed RPC-like client for React Query v5? Oh, yes!

```tsx
const {
  data,                   // <- fully typed response data
  error,                  // <- fully typed error data
} = tsr.getPost.useQuery({
  queryKey: ['posts'],
  queryData: {            // <- fully typed request data
    params: { id: '1' },
  },
  staleTime: 1000,        // <- react-query options (optional)
});
```

:::info

This documentation is for React Query v5. If you are looking for the v4 docs, please click [here](/docs/react-query-v4).

In order to use the React Query v5 version of `@ts-rest/react-query`, you need to import `@ts-rest/react-query/v5` and not `@ts-rest/react-query`.

:::

## Instructions

### 1. Installation

<InstallTabs packageName="@ts-rest/react-query @tanstack/react-query@5" />

### 2. Setup React Query

If you are not familiar enough with React Query, check out the [official `@tanstack/react-query` documentation](https://tanstack.com/query/v5/docs/framework/react/overview) to learn more about it and how to set it up.

Before proceeding, make sure you set up your `QueryClientProvider` at the root of your application or layout.

### 3. Initialize ts-rest React Query

Import your contract, and pass it with the client options to the `initTsrReactQuery` function. The client options are the same as the ones you would pass to the `initClient` function in `@ts-rest/core`.

```tsx
import { initTsrReactQuery } from '@ts-rest/react-query/v5';
import { contract } from './contract';

export const tsr = initTsrReactQuery(contract, {
  baseUrl: 'http://localhost:3333',
  baseHeaders: {},
});
```

### 4. Setup ts-rest Provider

Add the `tsr.ReactQueryProvider` to your root component, just below the `QueryClientProvider`. It is important that it lives as a child of the `QueryClientProvider` so that ts-rest can access the query client.

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import React from 'react';
import { tsr } from './tsr';

const queryClient = new QueryClient()

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <tsr.ReactQueryProvider>{children}</tsr.ReactQueryProvider>
    </QueryClientProvider>
  );
}
```

### 5.

???


### 6. Profit

You can now use the hooks from `tsr` in your components. The structure of the `tsr` container follows the same structure as your contract.

## Usage

```tsx
import { tsr } from './tsr';

const Posts = () => {
  const tsrQueryClient = tsr.useQueryClient();

  const { data, isLoading } = tsr.posts.get.useQuery({ queryKey: ['posts'] });
  const { mutate } = tsr.posts.create.useMutation({
    onMutate: (newPost) => {
      // get current posts, so we can reset back to it if the mutation fails
      const lastGoodKnown = tsrQueryClient.posts.get.getQueryData(['posts']);

      // optimistically update the cache with the new post
      tsrQueryClient.posts.get.setQueryData(['posts'], (old) => ({
        ...old,
        body: [
          ...old.body,
          {
            ...newPost.body,
            id: `placeholder-${Date.now()}`
          }
        ]
      }));

      // return the old posts to be stored in mutation context
      return { lastGoodKnown };
    },
    onError: (error, newPost, context) => {
      tsrQueryClient.posts.get.setQueryData(['posts'], context.lastGoodKnown);
    },
    onSettled: () => {
      // trigger a refetch regardless of it the mutation was successful or not
      tsrQueryClient.invalidateQueries({ queryKey: ['posts'] });
      //                 ^ QueryClient functions that do not consume or provide typed data are not wrapped by ts-rest
      // and are provided at the root level of tsrQueryClient for convenience
    },
  });

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (data?.status !== 200) {
    return <div>Error</div>;
  }

  return (
    <div>
      <ul>
        {data.body.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
      <button onClick={() => mutate({ body: { title: 'Hello World' } })}>Create Post</button>
    </div>
  );
};
```

All the hooks and `QueryClient` functions have the same function signatures and options exactly as the ones from `@tanstack/react-query`,
with the only difference being that you need to pass `queryData` instead of `queryFn`.

:::info

When destructing the response from `useQuery` or `useMutation`, remember that ts-rest returns a `status` and `body` property, so you'll need to destructure those as well.

The reason for this is error handling! Please see the [Relevant Docs](/docs/core/errors#client-error-typing)

:::

## Infinite Queries

For infinite query hooks such as `useInfiniteQuery` and `useSuspenseInfiniteQuery`, `queryData` should be a function that maps `pageParam` to the actual query data.

```tsx
import { tsr } from './tsr';

const PAGE_SIZE = 5;
const { data, isLoading, isError, fetchNextPage, hasNextPage } = tsr.getPosts.useInfiniteQuery({
  queryKey: ['posts'],
  queryData: ({ pageParam }) => ({
    query: {
      skip: pageParam.skip,
      take: pageParam.take,
    },
  }),
  initialPageParam: { skip: 0, take: PAGE_SIZE },
  getNextPageParam: (lastPage, allPages) => {
    return lastPage.body.posts.length >= PAGE_SIZE
      ? { take: PAGE_SIZE, skip: allPages.length * PAGE_SIZE }
      : undefined;
  },
});
```

See the [official `react-query` documentation](https://tanstack.com/query/v5/docs/framework/react/reference/useInfiniteQuery) for more information.

## useQueries

`useQueries` ([useQueries docs](https://tanstack.com/query/v5/docs/react/reference/useQueries)) is a great way to fetch multiple queries at once, or to dynamically fetch queries based on some condition. This is great because normally the number of useQuery hooks per component is fixed.

```tsx
import { tsr } from './tsr';

const Posts = () => {
  const queries = tsr.posts.get.useQueries({
    queries: [
      // <- This queries array can be changed at runtime!
      {
        queryKey: ['posts', '1'],
        queryData: {
          id: '1',
        },
      },
      {
        queryKey: ['posts', '2'],
        queryData: {
          id: '2',
        },
      },
    ],
  });

  if (queries.some((query) => query.isLoading)) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      {queries.map((query) => (
        <p key={query.data?.body.id}>{query.data?.body.title}</p>
      ))}
    </div>
  );
};
```

## Regular Query and Mutations

If you want to make `fetch` requests directly without going through React Query, we also expose `query` and `mutate` functions, so you do not have to initialize a separate fetch client.

```typescript
// Normal fetch
const { body, status } = await tsr.posts.get.query();

// useQuery hook
const { data, isLoading } = tsr.posts.get.useQuery();
```

## QueryClient Helpers

In addition to the hooks provided, `@ts-rest/react-query` can also wrap `QueryClient` in order to fully type any function that sets or fetches data.

```tsx
import { tsr } from './tsr';

const Posts = () => {
  const POSTS_QUERY_KEY = ['posts'];

  const tsrQueryClient = tsr.useQueryClient();
  const { data, isLoading } = tsr.posts.get.useQuery({ queryKey: POSTS_QUERY_KEY });
  const { mutate } = tsr.posts.create.useMutation();

  const createPost = async () => {
    return mutate(
      { body: { title: 'Hello World' } },
      {
        onSuccess: async (data) => {
          //  this is typed ^
          tsrQueryClient.posts.get.setQueryData(POSTS_QUERY_KEY, (oldPosts) => {
            //                                     this is also typed ^
            return {
              ...oldPosts,
              body: [...oldPosts.body, data.body],
            };
          });
        },
      },
    );
  };

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (data?.status !== 200) {
    return <div>Error</div>;
  }

  return (
    <div>
      <button onClick={createPost}>Create Post</button>
      {data.body.map((post) => (
        <p key={post.id}>post.title</p>
      ))}
    </div>
  );
};
```

## Error Handling

If a request fails, the `error` property will be set to the response from the server, or the thrown error by `fetch`. This is the same as the `data` property for successful requests.

The type of the `error` property on the React Query hooks will be set as `{ status: ...; body: ...; headers: ... } | Error`, where status is a non-2xx status code, and `body`
set to your response schema for status codes defined in your contract, or `unknown` for status codes not in your contract.

The `Error` type is included because requests can fail without returning a response. See [Fetch#Exceptions](https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions) for more information.

## Troubleshooting

### `No QueryClient set, use QueryClientProvider to set one`

If you see this error despite having set a `QueryClient` using `QueryClientProvider`. Then you might have different versions of `@tanstack/react-query` installed in your project.

This can also happen in rare cases when ESM and CJS versions of the package are mixed by a bundler like Webpack.

If you have made sure that you are using the same version of `@tanstack/react-query` across your project, and are still having problems, you can work around this
by importing `@tanstack/react-query` from `@ts-rest/react-query/tanstack` instead of `@tanstack/react-query`. This will ensure that you are using the same version as the one used
by `@ts-rest/react-query`.

```tsx
import { QueryClient, QueryClientProvider } from '@ts-rest/react-query/tanstack';

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}
```
